import { defineStore } from "pinia";
import { finalizeEvent } from "nostr-tools";
import { pool } from "@/nostr/relays";
import { getRelaysFromStorage } from "@/nostr/relays";
import { useKeyStore } from "@/stores/keys";
import { genSymHex, symEncryptPackage, envelopeEncryptSym } from "@/nostr/crypto";

type OutboxItem = {
  id: string;
  created_at: number;
  content: string;
};

type UnsignedEvent = {
  kind: number;
  pubkey: string;
  created_at: number;
  tags: string[][];
  content: string;
};

/**
 * posts store（不在 tags 写 p，按你选择）
 * - publishNip44PerMessage: per-message 对称密钥 + per-recipient envelope（payload.keys 包含 recipients）
 *   注意：content 中会包含 recipients 信息（任何能读取 event content 的人可见）
 */
export const usePostsStore = defineStore("posts", {
  state: () => ({
    outbox: [] as OutboxItem[],
  }),
  actions: {
    loadOutbox() {
      try {
        const raw = localStorage.getItem("nostr-outbox");
        if (raw) this.outbox = JSON.parse(raw);
      } catch (e) {
        // ignore parse errors but keep console for debugging
        console.warn("loadOutbox failed", e);
        this.outbox = [];
      }
    },

    reset() {
      this.outbox = [];
      try {
        localStorage.removeItem("nostr-outbox");
      } catch (e) {
        console.warn("reset outbox failed", e);
      }
    },

    async publishNip44PerMessage(recipients: string[], plaintext: string) {
      const key = useKeyStore();
      if (!key.skHex || !key.pkHex) throw new Error("未登录");

      if (!Array.isArray(recipients) || recipients.length === 0) {
        throw new Error("recipients 不能为空");
      }

      // 不修改外部传入的 recipients 参数
      const finalRecipients = recipients.includes(key.pkHex)
        ? recipients
        : [...recipients, key.pkHex];

      // per-message symmetric key
      const symHex = genSymHex();
      const pkg = await symEncryptPackage(symHex, plaintext);

      // 并行为所有 recipients 创建 envelope 加密（性能更好）
      const keysArr: Array<{ to: string; enc: string }> = await Promise.all(
        finalRecipients.map(async (r) => {
          const enc = await envelopeEncryptSym(key.skHex, r, symHex);
          return { to: r, enc };
        })
      );

      const payload = { version: "nip-44-per-message-v1", keys: keysArr, pkg };
      const contentStr = JSON.stringify(payload);

      const event: UnsignedEvent = {
        kind: 24242,
        pubkey: key.pkHex,
        created_at: Math.floor(Date.now() / 1000),
        tags: [], // 不写 p
        content: contentStr,
      };

      const signed = finalizeEvent(event as any, key.skHex);

      // use relays from storage (settings)
      const relays = getRelaysFromStorage();
      const publishPromises = pool.publish(relays, signed);

      // 收集每个 relay 的发布结果，便于日志/重试决策
      const publishReport = await Promise.all(
        publishPromises.map((p: Promise<any>) =>
          p
            .then((res) => ({ ok: true, res }))
            .catch((error) => ({ ok: false, error }))
        )
      );

      // 可选：把 publishReport 打印到控制台便于调试
      console.debug("publishNip44PerMessage publishReport:", publishReport);

      // 更新 outbox（限制容量，避免无限增长）
      const MAX_OUTBOX = 200;
      this.outbox.unshift({
        id: signed.id,
        created_at: signed.created_at,
        content: contentStr,
      });
      this.outbox = this.outbox.slice(0, MAX_OUTBOX);

      try {
        localStorage.setItem("nostr-outbox", JSON.stringify(this.outbox));
      } catch (e) {
        console.warn("save outbox failed", e);
      }

      // 如果你想在外层知道具体每个 relay 是否成功，可以返回 publishReport
      return { signed, publishReport };
    },
  },
});

